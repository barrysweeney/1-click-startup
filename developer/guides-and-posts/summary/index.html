<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>1 Click Startup | Developer Guide</title>
    <link
            rel="stylesheet"
            href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"
            integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk"
            crossorigin="anonymous"
    />
    <link rel="shortcut icon" type="image/png" href="assets/bs-logo.png"/>
    <link href="themes/prism.css" rel="stylesheet"/>
    <link rel="stylesheet" href="style.css"/>
</head>
<body>
<div class="container">
    <div class="toolbar" role="banner">
        <span class="logo"> 📈 </span>
        <span>1 Click Startup</span>
    </div>
    <hr/>
    <div class="toolbar" role="banner">
        <span class="logo"> 📊 💬 📄 </span>
    </div>
    <div class="who">
        <h3>Who is it for?</h3>
        <hr/>
        <p>The owner of a small business such as a fast-food restaurant.</p>
    </div>
    <div class="what">
        <h3>What does it do?</h3>
        <hr/>
        <p>With one click, a full IT system is set up for the business which will allow the business owner and employees
            to interact with familiar software to make sure the work that needs done for their job gets done.</p>
    </div>
    <div class="how">
        <h3>How does it do this?</h3>
        <hr/>
        <p>The end project will make use of open source software running in <a href="https://www.docker.com/">Docker</a>
            containers and using a <a
                    href="https://flask.palletsprojects.com/en/1.1.x/">Flask</a> <a
                    href="https://www.youtube.com/watch?v=7YcW25PHnAA">REST API</a> webserver to simplify interactions
            with the software services.</p>
        <p>We also provide custom, web user interfaces to help make running the business via these services
            intuitive.</p>
        <ul>
            <li><strong>Manager Interface.</strong> The manager interface streamlines communication between the business
                entities: manager, employees, and suppliers
            </li>
            <li><strong>Employee Interface.</strong> Employees fill in a series of digital forms which log important
                information about the processes they complete in their work.
            </li>
        </ul>
    </div>
    <div>
        <h3>How do we test the system?</h3>
        <hr/>
        <p>We also want to provide a testing framework with simulated users and managers using a
            tool such as <a href="https://selenium-python.readthedocs.io/">PySelenium</a>.</p>
    </div>
    <div class="toc">
        <h2>What's In This Document</h2>
        <hr/>
        <ul>
            <li><a href="#understand-business">Understanding a business</a></li>
            <li><a href="#up-and-run">Getting the current system up and running</a></li>
            <li><a href="#new-service">Adding a new service</a></li>
            <li><a href="#custom-webserver">Custom Webserver</a></li>
            <li><a href="#automated-employee-demo">Automated Employee Demo</a></li>
            <li><a href="#automated-employee-demo">AI Manager Demo</a></li>
            <li><a href="#process-mining">Adding Problems</a></li>
            <li><a href="#ux">Work Still to do</a></li>
        </ul>
    </div>
    <div id="understand-business">
        <h3>👤 Understanding a business</h3>
        <hr/>
        <p>We want to solve problems our user is facing and improve their overall work-flow. In order to do that we
            need to define our user and figure out more specific details regarding their current work-flows.</p>
        <p>After conducting a survey with Google forms and an in person interview with a local business owner, the
            following use cases have been identified. These are jobs we want to incorporate into our product to improve
            the user's workflow.</p>
        <h5 id="use-cases">Use Cases</h5>

        <h6>Manager Use Cases</h6>
        <table>
            <tr>
                <th>Situation (When)</th>
                <th>Motivation (I want to)</th>
                <th>Expected Outcome (So I can)</th>
            </tr>
            <tr>
                <td>Stock is low</td>
                <td>Order Stock</td>
                <td>Be prepared for orders</td>
            </tr>
            <tr>
                <td>Employee joins</td>
                <td>Train employee</td>
                <td>Confidently put them on a shift</td>
            </tr>
            <tr>
                <td>Employee leaves</td>
                <td>Hire employee</td>
                <td>Have sufficient staff</td>
            </tr>
            <tr>
                <td>Customer complains</td>
                <td>Communicate with customer</td>
                <td>Apologize and find problem source</td>
            </tr>
            <tr>
                <td>Quality decreases</td>
                <td>Communicate with staff</td>
                <td>Get standards back to where they should be</td>
            </tr>
            <tr>
                <td>Shift ends</td>
                <td>Record sales</td>
                <td>Update accounts and make predictions</td>
            </tr>
            <tr>
                <td>Sales decrease</td>
                <td>Communicate with staff and investigate other local businesses
                </td>
                <td>Determine the cause of sales decreasing</td>
            </tr>
            <tr>
                <td>Product sells out</td>
                <td>Make product unavailable</td>
                <td>Stop taking orders</td>
            </tr>
            <tr>
                <td>Week is about to begin</td>
                <td>Send hours to staff</td>
                <td>Make any necessary changes</td>
            </tr>
            <tr>
                <td>Week is over</td>
                <td>Pay staff</td>
                <td>Keep their next wage payment separate</td>
            </tr>
            <tr>
                <td>Employee complains</td>
                <td>Communicate with employee</td>
                <td>Determine cause of complaint and potential solutions</td>
            </tr>
            <tr>
                <td>Bill arrives by post</td>
                <td>Pay bill</td>
                <td>Not accrue additional fees</td>
            </tr>
            <tr>
                <td>Problem with stock</td>
                <td>Contact supplier</td>
                <td>Get a refund or replacement</td>
            </tr>
        </table>
        <h6>Employee Use Cases</h6>
        <table>
            <tr>
                <th>Situation (When)</th>
                <th>Motivation (I want to)</th>
                <th>Expected Outcome (So I can)</th>
            </tr>
            <tr>
                <td>Phone rings</td>
                <td>Answer</td>
                <td>Take order or answer customer query</td>
            </tr>
            <tr>
                <td>Order comes through app</td>
                <td>Read order</td>
                <td>Prepare order</td>
            </tr>
            <tr>
                <td>Shift begins</td>
                <td>Turn on equipment
                </td>
                <td>Prepare orders later</td>
            </tr>
            <tr>
                <td>Shift ends</td>
                <td>Turn off equipment</td>
                <td>Prevent fire risk and electricity cost</td>
            </tr>
            <tr>
                <td>There are no orders to be made</td>
                <td>Clean or prepare for future orders</td>
                <td>Be prepared for future orders</td>
            </tr>
            <tr>
                <td>Shift needs changed</td>
                <td>Communicate with management and colleagues</td>
                <td>Have colleague cover shift and hours updated</td>
            </tr>
            <tr>
                <td>Shift ends</td>
                <td>Lock shop</td>
                <td>Keep equipment and cash inside safe</td>
            </tr>
            <tr>
                <td>Shift ends</td>
                <td>Count cash
                </td>
                <td>Send sales details to manager</td>
            </tr>
            <tr>
                <td>Shift ends</td>
                <td>Clean and prepare equipment for next day</td>
                <td>Not be reprimanded</td>
            </tr>
            <tr>
                <td>Customer enters shop</td>
                <td>Approach customer</td>
                <td>Take their order</td>
            </tr>
            <tr>
                <td>Customer order ready</td>
                <td>Give it to the customer and take their payment</td>
                <td>Complete the order</td>
            </tr>
        </table>
        <p>If we think about think about completing these tasks in terms of webpages we see that for communication or
            record keeping we can provide forms on the user interface but for tasks which need performed physically such
            as turning off equipment we can just provide a form to acknowledge that the task has been completed.</p>
        <p>Open source software can enable us to automate some of the tasks required to run the business. Stock could be
            automatically re-ordered for example. Open source communication services can also be employed.</p>
    </div>
    <div class="quickstart" id="up-and-run">
        <h3>🛫 Getting the current system up and running</h3>
        <hr/>
        <p id="prereq">It may seem like a lot of initial setup if you're new to the tools but it'll be well worth it.
            Getting
            familiar with these tools will put you in good stead to take your ability as a software engineer to the next
            level and will set you apart from others interviewing for entry-level software engineering jobs.</p>
        <h4>Set up Git and GitHub</h4>
        <p>We'll begin by getting the necessary files onto your machine with Git</p>
        <p>From <a href="https://www.theodinproject.com/courses/foundations/lessons/introduction-to-git">The Odin
            Project - Introduction to Git</a>:</p>
        <blockquote>"Git is like a really epic save button for your files and directories. Officially, Git is a version
            control system.
        </blockquote>
        <p>The next few steps have been adapted from <a
                href="https://www.theodinproject.com/courses/foundations/lessons/setting-up-git">The Odin Project
            - Configure Git (Linux or Mac) and Github
            (all operating systems)</a></p>
        <p>First we open a new terminal with the key combination <code>ctrl+alt+t</code> or alternatively search for
            "terminal"</p>
        <img src="assets/open-terminal.png">
        <p>From there we can run these commands in the terminal to update the Linux system</p>
        <pre><code class="language-bash">sudo apt update
sudo apt upgrade</code></pre>
        <p>And to install git</p>
        <pre><code class="language-bash">sudo add-apt-repository ppa:git-core/ppa
sudo apt update
sudo apt install git</code></pre>
        <p>Now we can configure Git and GitHub. Be sure to enter your own information inside the quotes (but include the
            quotation marks).</p>
        <pre><code class="language-bash">git config --global user.name "Your Name"
git config --global user.email "yourname@example.com"</code></pre>
        <p>We change Git's default branch (don't worry about the Git terminology here) to main to match GitHub's default
            branch name</p>
        <pre><code class="language-bash">git config --global init.defaultBranch main</code></pre>
        <p>Next you can go to <a href="https://github.com/">GitHub.com</a> and create an account if you don't already
            have one.</p>
        <p>That completes our Git setup.</p>
        <p>After getting our project up and running, to get started with Git I recommend returning <a
                href="https://www.youtube.com/watch?v=HVsySz-h9r4">this video by Cory
            Schafer</a> and <a href="https://www.theodinproject.com/courses/foundations/lessons/git-basics">this Git
            lesson on The Odin Project</a>. Try not to feel too overwhelmed by all the commands at this point, as you'll
            soon find out there are only a few commands you'll use in your <strong>basic Git workflow</strong></p>
        <p>Now we can get all the files you need to get up and running on your machine.</p>
        <p>The next few steps have been adapted from <a
                href="https://help.github.com/articles/fork-a-repo/"> GitHub Docs - Fork a repo</a></p>
        <p>On GitHub, we go to the <a href="https://github.com/barrysweeney/1-click-startup">1 Click Startup
            repository</a></p>
        <p>We click to fork the repository, essentially creating a new copy that doesn't affect the original</p>
        <img src="assets/fork.png">
        <p>Now we can clone the forked repository so you have the files available on your machine as well as on your
            GitHub account.</p>
        <p>You can modify the following URL with your GitHub username to find your forked repository:
            https://github.com/YOUR-GITHUB-USERNAME/1-click-startup</p>
        <p>We can click the code button above the list of files</p>
        <img src="assets/code-button.png">
        <p>Next, to clone the repository with HTTPS you can click the clipboard icon to copy the URL (note the URL
            should look like https://github.com/YOUR-GITHUB-USERNAME/1-click-startup )</p>
        <img src="assets/https-clipboard.png">
        <p>Now we can go back to our terminal and type git clone and paste the copied URL with <code>ctrl+shift+v</code>
        </p>
        <p>It should look something like this</p>
        <pre><code class="language-bash">git clone https://github.com/YOUR-GITHUB-USERNAME/1-click-startup</code></pre>
        <p>If we hit enter the local clone should be created and we should have all the files we need.</p>
        <h4>Set up Docker and Docker Compose</h4>
        <h5>Set up Docker Engine</h5>
        <p>We'll install Docker so we can run our different services (frontend UI, database, etc) in containers to limit
            the number of services we need to install locally.</p>
        <p>From <a href="https://www.docker.com/why-docker">Docker</a>:</p>
        <blockquote>"Containers are a standardized unit of software that allows developers to isolate their app from its
            environment, solving the “it works on my machine” headache. For millions of developers today, Docker is the
            de
            facto standard to build and share containerized apps"
        </blockquote>
        <p> This guide includes installing Docker engine on Ubuntu. For other operating systems, Linux platforms, and
            alternative install methods I'll point you to these guides to</p>
        <ul>
            <li><a target="_blank" href="https://docs.docker.com/engine/install/"
            >Install Docker Engine on Linux</a
            ></li>
            <li><a target="_blank" href="https://docs.docker.com/docker-for-mac/install/"
            >Install Docker Desktop on MAC</a
            ></li>
            <li><a target="_blank" href="https://docs.docker.com/docker-for-windows/install/"
            >Install Docker Desktop on Windows</a
            ></li>
        </ul>
        <p>The following steps are adapted from <a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker
            Engine on Ubuntu</a></p>
        <p>If you think you may have some older versions of Docker installed tou can uninstall them with</p>
        <pre><code class="language-bash">sudo apt-get remove docker docker-engine docker.io containerd runc</code></pre>
        <p>Next we'll set up the Docker repository. First we'll update the apt package index and install the packages
            that allow apt to use a repository over HTTPS.</p>
        <pre><code class="language-bash">sudo apt-get update
sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ gnupg-agent \ software-properties-common</code></pre>
        <p>Next we'll add the official Docker GPG key:</p>
        <pre><code class="language-bash">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</code></pre>
        <p>And we can set up the stable repository with the following command</p>
        <pre><code class="language-bash">echo \
  "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null</code></pre>
        <p>We can now install the latest version of Docker Engine and containerd</p>
        <pre><code class="language-bash">sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre>
        <h5>Set up Docker Compose</h5>
        <p>Next we'll install Docker Compose</p>
        <p>From <a href="https://docs.docker.com/compose/">Docker - Overview of Docker Compose</a>:</p>
        <blockquote>"Compose is a tool for defining and running multi-container Docker applications."</blockquote>
        <p>The following steps are adapted from <a href="https://docs.docker.com/compose/install/">Docker - Install
            Docker Compose</a></p>
        <p>This is the command we can use to install Compose on Linux systems, for other systems and alternative install
            options you can use <a href="https://docs.docker.com/compose/install/">Docker - Install Docker Compose</a>
        </p>
        <pre><code class="language-bash">sudo curl -L "https://github.com/docker/compose/releases/download/1.28.6/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</code></pre>
        <p>And we can apply executable permissions with</p>
        <pre><code class="language-bash">sudo chmod +x /usr/local/bin/docker-compose</code></pre>
        <h4>Set up IDE</h4>
        <p>We'll be using Visual Studio Code (VS Code) for the purpose of this guide due to it's versatility; allowing
            us to code JavaScript
            and Python in the same editor.</p>
        <p>I think the easiest way is to open up Ubuntu Software which should appear when you start searching for
            "ubuntu"</p>
        <img src="assets/usoft.png" alt="Searching Ubuntu desktop for Ubuntu Store">
        <p>From inside the Software store you can use the 🔎 icon and start searching for "vscode"</p>
        <img src="assets/vscode-search.png" alt="Searching for Visual Studio Code on the Ubuntu Software store">
        <p>And we can now click the install button</p>
        <img src="assets/vscode-install-button.png" alt="Visual Studio Code install button">
        <p>We can now search for "vscode" and at this point I like to add to favourites so I can access VS Code from the
            application drawer</p>
        <img src="assets/vscode-favourite.png"
             alt="Searching for Visual Studio Code on Ubuntu with the add to favourites option highlighted">
        <p>THe following section of the tutorial draws from <a
                href="https://code.visualstudio.com/docs/python/python-tutorial">Getting Started with Python in VS
            Code</a> You can now open a new window of Visual Studio Code</p>
        <img src="assets/vscode-new-window.png"
             alt="Searching for Visual Studio Code on Ubuntu with the New Window option highlighted">
        <p>Now we can navigate to the extensions tab</p>
        <img src="assets/extensions.png" alt="Visual Studio Code menu with extensions tab highlighted"
             class="extensions-img">
        <p>And download the Python extension</p>
        <img src="assets/python-extension-vscode.png" alt="Python VS Code extension with install button">
        <p>As Ubuntu comes with Python3 pre-installed we can move on to installing pip. (For other Operating Systems you
            can see options like brew for MacOS and WSL for Windows in <a
                    href="https://code.visualstudio.com/docs/python/python-tutorial">Getting Started with Python in VS
                Code</a> )</p>
        <p>To install pip...</p>
        <pre><code class="language-bash">sudo apt install -y python3-pip</code></pre>
        <p>We can now open our Flask code and select our Python interpreter</p>
        <p>From <a
                href="https://code.visualstudio.com/docs/python/python-tutorial">Getting Started with Python in VS
            Code</a></p>
        <blockquote>"Python is an interpreted language, and in order to run Python code and get Python IntelliSense, you
            must tell VS Code which interpreter to use."
        </blockquote>
        <p>Inside the cloned 1-click-startup repository you'll see a folder "1cs-backend" which you can right click to
            select open with other application</p>
        <img src="assets/open-with-vscode.png">
        <p>We can select VS Code and from here, we can install a virtual environment. Here's what the Visual Studio Code
            guide referenced above
            has to say about them:</p>
        <blockquote>"A best practice among Python developers is to avoid installing packages into a global interpreter
            environment. You instead use a project-specific virtual environment that contains a copy of a global
            interpreter. Once you activate that environment, any packages you then install are isolated from other
            environments. Such isolation reduces many complications that can arise from conflicting package versions."
        </blockquote>
        <p>Within VS Code you can use <code>ctrl+alt+`</code> to open a terminal and type the following to setup and
            activate the virtual environment</p>
        <pre><code class="language-bash">python3 -m venv .venv
source .venv/bin/activate</code></pre>
        <p>We can use <code>ctrl+shift+p</code> to open the command palette and start typing "python:select interpreter"
        </p>
        <img src="assets/python-select-interpreter.png">
        <p>And select our interpreter from the menu (or navigate to the folder on your system)</p>
        <img src="assets/venv-interpreter.png">
        <p>We can install the packages required by our backend code by running the following command within our
            activated virtual environment</p>
        <pre><code class="language-bash">pip3 install -r requirements.txt</code></pre>
        <p>That's all the work done to set up our python backend. If you try to run the code now you'll still get errors
            because we are yet to setup our database etc.</p>
        <h4>Run development containers</h4>
        <p>To run our development containers we'll navigate to where we've cloned the files locally which can be done by
            opening a terminal with <code>ctrl+alt+t</code></p>
        <p>From here we can change directory to the cloned repository with</p>
        <pre><code class="language-bash">cd 1-click-startup</code></pre>
        <p>Now we can run</p>
        <pre><code class="language-bash">sudo docker-compose up</code></pre>
        <p>The relevant ports are now exposed and can be accessed on your local machine</p>
        <p>The <strong>Frontend Interface</strong> is accessible at <a href="http://localhost:8000">http://localhost:8000</a>
        </p>
        <p>This frontend connects to the <strong>Backend Webserver</strong> at <a href="http://localhost:5000">http://localhost:5000</a>
        </p>
        <p>Requests are made form the backend to the <strong>MySQL Database</strong> at <a href="http://localhost:3306">http://localhost:3306</a>
        </p>
        <p>For more control over the database in development, a database graphical interface - <strong>Adminer</strong>
            - is accessible at <a href="http://localhost:8080">http://localhost:8080</a></p>
        <p>To login we enter our server as "mysqldb", username as "root" and password as "p@ssw0rd1"</p>
        <img src="assets/adminer-login.png">
        <p>This configuration information as well as other ports exposed for user automation can be found in the
            <code>docker-compose.yaml</code> file at the root of the cloned directory.</p>
        <p>Additional ports have been exposed such as</p>
        <p>We'll dive a little deeper into this file when we move on to adding a service later but for now we can take a
            quick look so you get the general idea of how we tell our application which services to start and what port
            to expose them on:</p>
        <img src="assets/compose-yaml.png">
        <p>Essentially we either provide a path to a Dockerfile to build the service (as done with the backend service)
            or we name the image as an existing service we want to use such as with the mysql image (this image is then
            pulled from <a href="https://hub.docker.com/">Docker Hub</a>)</p>
        <p>We don't need to worry too much about all of the commands right now as we'll see them again later when we're
            adding a new service.</p>
        <p>*******************************************************</p>
        <p>From <a href="https://www.selenium.dev/">Selenium</a>:</p>
        <blockquote>"Selenium automates browsers. That's it!
            What you do with that power is entirely up to you.

            Primarily it is for automating web applications for testing purposes, but is certainly not limited to just
            that.

            Boring web-based administration tasks can (and should) also be automated as well."
        </blockquote>
    </div>
    <div class="custom-webserver" id="custom-webserver">
        <h3>💽 Custom Webserver</h3>
        <hr>
        <p>From <a href="https://pythonbasics.org/what-is-flask-python/">Python Basic - What is Flask Python?</a>:</p>
        <blockquote>"Flask is a web application framework written in Python.

            A Web Application Framework or simply a
            Web Framework represents a collection of libraries and
            modules that enable web application developers to write applications without worrying about low-level
            details"
        </blockquote>
        <p>When a user submits a form or clicks a button on the font-end user interface in their browser, a request is
            made to certain endpoint on the "backend" webserver. For example, when a user attempts to login, their email
            and password is sent to the Flask webserver which then performs the authentication.</p>
        <p>Let's start running through the code.</p>
        <p>We start by importing the relevant packages which are either shipped with Python or installed using pip from
            our <code>requirements.txt</code> file.</p>
        <pre><code class="language-python"># For handling requests and responses
import json
from flask import Flask, request
# For database connection
import mysql.connector
# For password encryption
from passlib.hash import sha256_crypt
# To enable requests from the frontend user interface
from flask_cors import CORS, cross_origin</code></pre>
        <p>We then create and configure the app</p>
        <pre><code class="language-python"># Create Flask instance
app = Flask(__name__)</code></pre>
        <p>From <a href="https://flask.palletsprojects.com/en/1.1.x/tutorial/factory/">Flask - Application Setup</a>:
        </p>
        <blockquote><code>__name__</code> is the name of the current Python module. The app needs to know where it’s
            located to set up some paths, and <code>__name__</code> is a convenient way to tell it that.
        </blockquote>
        <p>Next, we use the <code>flask_cors</code> module to allow communication between our frontend interface and
            backend webserver.</p>
        <pre><code class="language-python"># Enable CORS to permit requests from the frontend to the backend (a different origin)
CORS(app) # Enables CORS for all routes
# Allow Content-Type header
app.config['CORS_HEADERS'] = 'Content-Type'</code></pre>
        <p>From <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">MDN Web Docs - CORS</a>:</p>
        <blockquote><strong>Cross-Origin Resource Sharing</strong> (CORS) is an HTTP-header based mechanism that allows
            a server to
            indicate any other origins (domain, scheme, or port) than its own from which a browser should permit loading
            of resources
        </blockquote>
        <p>Although we've created a dependency between the MySQL and Flask server containers in the <code>docker-compose.yaml</code>
            file using <code>depends_on</code>, we still need to wait for the MySQL server <em>within</em> the container
            to be ready for connections.</p>
        <pre><code class="language-python"># Wait for MYSQL container to be ready for connection before allowing requests to database
ready = False
while not ready:
    try:
        # Connect to db with parameters matching docker-compose.yaml file
        mydb = mysql.connector.connect(
            host="mysqldb",
            user="root",
            password="p@ssw0rd1"
        )
        # Create cursor
        cursor = mydb.cursor()
        # Create and use database "startup" if it doesn't exist
        # TODO: Implement persistent database storage with volume mounting
        cursor.execute("CREATE DATABASE startup IF NOT EXISTS ")
        cursor.execute("USE startup")
        # Create "users" table if it doesn't exist
        cursor.execute(
            "CREATE TABLE IF NOT EXISTS users (id int(11) AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), email VARCHAR(255) UNIQUE , password VARCHAR(255), role VARCHAR(255), business VARCHAR(255), can_log_in BOOLEAN)")
        # Close connection
        cursor.close()
        mydb.close()
        # Break out of while loop by setting ready to True
        ready = True
    except mysql.connector.errors.InterfaceError:
        # Try to connect to database again
        continue</code></pre>
        <p>Next we'll look at two routes in a little bit more detail. We'll first look at user registration as an
            introduction to our authentication routes.</p>
        <pre><code class="language-python"># Authentication

# User registration route
@app.route('/register', methods=['POST'])
@cross_origin()
def register():
    # Get values from json request body
    data = request.json
    name = data['name']
    email = data['email']
    role = data['role']
    business = data['business']
    # Encrypt plain text password
    password = sha256_crypt.encrypt(data['password'])
    # Employees can't log in until manager approves
    can_log_in = False
    # Managers can log in immediately
    if role == "manager":
        can_log_in = True

    # Connect to db with parameters matching docker-compose.yaml file
    mydb = mysql.connector.connect(
        host="mysqldb",
        user="root",
        password="p@ssw0rd1",
        database="startup"
    )

    # Create cursor
    cursor = mydb.cursor()

    # Execute query to add user to database users table
    cursor.execute(
        "INSERT INTO users(name, email, password, role, business, can_log_in) VALUES(?, ?, ?, ?, ?, ?)",
        (name, email, password, role, business, can_log_in,))

    # Commit data to db
    mydb.commit()

    # Close connection
    cursor.close()
    mydb.close()

    # Return success message
    return json.dumps({'success': True}), 200, {'ContentType': 'application/json'}</code></pre>
        <p>Essentially what we have above is that the user will enter their email, password, business, and role, into a
            form on the frontend. THe data is then sent to the flask server which will store the users details in the
            database. Managers can log in immediately but employees will need to wait for manager's approval before they
            log in since their <code>can_log_in</code> flag will initially be false.</p>
        <p>Next we'll take a look at the route used to complete a customer order.</p>
        <pre><code class="language-python"># Store new customer order in the database
# TODO: Restrict route to logged in users
# TODO: Link order to business
# TODO: Reduce stock level of ordered items
@app.route('/customer/order/new', methods=['POST'])
@cross_origin()
def customer_order():
    # get values from json request body
    data = request.json
    customer_name = data['name']
    contact_number = data['number']
    customer_order = data['order']

    # Connect to db with parameters matching docker-compose.yaml file
    mydb = mysql.connector.connect(
        host="mysqldb",
        user="root",
        password="p@ssw0rd1",
        database="startup"
    )

    # Create cursor
    cursor = mydb.cursor()

    # insert values from form into new record in CUSTOMER_ORDER table
    cursor.execute("INSERT INTO customer_order (customer_name, contact_number, customer_order) \
     VALUES (%s,%s,%s)", (customer_name, contact_number, customer_order))

    # Commit data to db
    mydb.commit()

    # Close connection
    cursor.close()
    mydb.close()

    # Return success message
    return json.dumps({'success': True}), 200, {'ContentType': 'application/json'}</code></pre>
        <p>You'll notice some similarities across the routes as we're typically doing the following steps:</p>
        <ul>
            <li>Extract data from request</li>
            <li>Connect to database</li>
            <li>Interact with database</li>
            <li>Close database connection</li>
            <li>Send response to user</li>
        </ul>
        <p>One last thing we'll mention before we move onto adding a new service to the application is the idea of
            extracting data from the URL. For example:</p>
        <pre><code class="language-python"># Get an employees details from the database using their id
@app.route("/employee/&lt;id&gt;")
def get_employee(id):
    return 'Not yet implemented'</code></pre>
        <p>Using the <code>&lt;id&gt;</code> syntax in the route and having the <code>id</code> as a method parameter
            allows us to
            use <code>id</code> inside the method which will allow us to search the database by id for example.</p>
    </div>
    <div class="new-service" id="new-service">
        <h3>➕ Adding a new service</h3>
        <hr>
        <p>Many small businesses use spreadsheets to manage payroll and sales predictions as opposed to expensive
            proprietary specialized applications.</p>
        <p>Let's add NextCLoud which will allow our user to use the integrated Collabora Office Online to manage and edit documents.</p>
        <p>Firstly, we'll need to modify our <code>docker-compose.yml</code> file to add the new service</p>
        <pre><code class="language-yaml">version: "3.7"

services:
  frontend:
    ...

  backend:
    ...

  adminer:
    ...

  db:
    ...

  nextcloud:
    image: nextcloud
    restart: always
    ports:
      - 80:80
    links:
      - db
    volumes:
      - nextcloud:/var/www/html
    environment:
      - MYSQL_PASSWORD=p@ssw0rd1
      - MYSQL_DATABASE=nextcloud
      - MYSQL_USER=nextcloud
      - MYSQL_HOST=db
    depends_on:
      - db

  pyselenium:
    ...

  firefox:
    ...

  selenium-hub:
    ...</code></pre>
        <p>We set the image to pull from Docker Hub, set some environment variables, and map the port from within the
            container to the same port on our local machine.</p>
        <p>Next we'll link this service to the custom frontend</p>
    </div>
    <div class="automated-employee-demo" id="automated-employee-demo">
        <h3>🤖 Automated Employee Demo</h3>
        <hr/>
        <p>User experience design details are listed below but for now I feel like it's worth skipping ahead to
            our first glimpse at automating our user, and work backwards from there.</p>
        <p>As one of the main goals of this project is to create automated users, it's worth exploring an example of one
            of the tasks that have been automated. </p>
        <p>We'll have <a href="https://selenium-python.readthedocs.io/">PySelenium</a> interact with our user interface
            to populate and submit a form to our backend <a
                    href="https://flask.palletsprojects.com/en/1.1.x/installation/">Flask</a>
            webserver which will then store data in a sqlite3 database.</p>
        <p><span aria-label="stop sign emoji">🛑</span> Hold Up <span aria-label="hand up for stop emoji">✋ </span>Before
            we go any further I'd like to mention that it isn't essential to understand concepts like <a
                    href="https://www.docker.com/resources/what-container">containers</a> and <a
                    href="https://docs.docker.com/compose/networking/">Docker
                compose network</a> at this point. When a new concept pops up I'll make sure to link to it's
            documentation for future
            reference. For now feel free to gloss over it and just get a feel for the overall flow of data and how our
            different services communicate. As an aside, the best resource I've found for learning these concepts was <a
                    href="https://www.pluralsight.com/courses/docker-kubernetes-big-picture">this course</a> which you
            can watch on a PluralSight free trial.</p>
        <p>In fact before we dive into code, let's set the scene with an analogy: We can think of containers as rooms in
            our hotel, and our "Docker network" as our hallway that connects all of our rooms. Our localhost is our
            hotel reception (or lobby if you prefer).</p>
        <p>When we run <code class="language-bash">sudo docker-compose up</code> we're starting different containers
            relating to our
            application.</p>
        <p>We're getting our rooms ready and letting our guests into them.</p>
        <p>Our automated user lives in one of these containers/rooms. With the following line of code, they can get the
            webdriver for Selenium which allows them to access the web.</p>
        <p>They walk down the corridor to the <a href="https://github.com/SeleniumHQ/docker-selenium">Webdriver</a> room
            to get the key for the door to the Web Browser room.</p>
        <pre>
        <code class="language-bash">driver = webdriver.Remote(<span class="red-code">desired_capabilities</span>=webdriver.DesiredCapabilities.FIREFOX,
            <span class="red-code">command_executor</span>=<span
                    class="green-code">"http://172.17.0.1:4444/wd/hub"</span>)</code></pre>
        <p>We use <span class="green-code">http://172.17.0.1</span> instead of <span
                class="green-code">http://localhost</span>
            since we're communicating from within one container to a different container, for more information about
            this bridge between networks using the host machine you can refer to <a
                    href="https://stackoverflow.com/q/48546124/9472445">this StackOverflow question by user klor</a>.
        </p>
        <p>With the next line of code our automated employee can access the customer order page of the frontend user
            interface which is in a different container accessible at port 8000 on our Docker network.</p>
        <pre><code class="language-bash">driver.get(<span
                class="green-code">"http://172.17.0.1:8000/customer-order"</span>)</code></pre>
        <p>This is what our employee now sees:</p>
        <img src="assets/customer-order.png" alt="Customer Order form"/>
        <p>They can now fill in and submit the form:</p>
        <pre><code class="language-python">
    driver.find_element_by_id(<span class="green-code">"customer-name"</span>).send_keys(<span class="green-code">"John Doe"</span>)
    driver.find_element_by_id(<span class="green-code">"customer-contact-number"</span>).send_keys(<span
                class="green-code">"+44700000010"</span>)
    driver.find_element_by_id(<span class="green-code">"customer-contact-number"</span>).send_keys("<span
                class="green-code">Bottle Water"</span>)
    driver.find_element_by_id(<span class="green-code">"submit-customer-order"</span>).click()
        </code></pre>
        <p>If we look at the code for this form we can see that it is sending a <a
                href="https://en.wikipedia.org/wiki/POST_(HTTP)">POST</a> request to our backend Flask
            webserver running on port 5000 of our Docker network (We take the letter we wrote in the frontend room to
            Flask's room).</p>
        <pre><code class="language-bash"><span class="yellow-code">&lt;form</span> method=<span class="green-code">"post"</span> action=<span
                class="green-code">"http://172.17.0.1:5000/customer/order/new"</span><span
                class="yellow-code">&gt;</span>...</code></pre>
        <p>Let's look at what's happening over on the server side by visiting our Flask webserver.</p>
        <pre><code class="language-python">
<span class="yellow-code">@app.route</span>(<span class="green-code">'/customer/order/new'</span><span
                class="orange-code">,</span> <span class="red-code">methods</span>=[<span
                class="green-code">'post'</span>])
<span class="orange-code">def</span> <span class="yellow-code">customer_order</span>():
    name = request.form[<span class="green-code">'customer-name'</span>]
    contact_number = request.form[<span class="green-code">'customer-contact-number'</span>]
    order = request.form[<span class="green-code">'customer-order'</span>]
    c.execute(<span class="green-code">"</span><span class="orange-code">INSERT INTO</span> CUSTOMER_ORDER(CUSTOMER_NAME,CONTACT_NUMBER,CUSTOMER_ORDER) \
    <span class="orange-code">VALUES</span> (?<span class="orange-code">,</span>?<span
                class="orange-code">,</span>?)<span class="green-code">"</span><span
                class="orange-code">,</span> (name<span class="orange-code">,</span> contact_number<span
                class="orange-code">,</span> order<span class="orange-code">,</span>))
    conn.commit()
    <span class="orange-code">return</span> <span class="green-code">'OK'</span>
        </code></pre>
        <p>We're extracting the data from the form that was posted and inserting it as an new record into our customer
            order table.</p>
        <p>We can see that Flask and sqlite3 share the same room, if it start's getting too crowded we might want to
            prepare a new room for sqlite3</p>
        <p>Although this is only a single <a href="#use-cases">use case</a>, that of an employee taking a customer
            order, it highlights the flow of data through some of our integrated services.</p>
    </div>
    <div class="automated-manager-demo" id="automated-manager-demo">
        <h3>📊 Automated Manager Demo</h3>
        <hr>
    </div>
    <div class="adding-problems" id="adding-problems">
        <h3>⛈ Adding work problems in the application</h3>
        <hr>
    </div>
    <div class="next-steps" id="next-steps">
        <h3>📋 Next Steps</h3>
        <hr>
    </div>
    <div>
        <h3>Troubleshooting</h3>
        <li><code class="language-shell">Error: for db ... 0.0.0.0:3306: bind: address already in use</code> - to solve
            this you can find which process is using the port by running <code>sudo lsof -i -P -n | grep 3306</code> and
            use the id to end the process with <code>sudo kill id</code> for example <br>
            <img src="assets/lsof.png">
        </li>
    </div>

</div>
<script src="prism.js"></script>
</body>
</html>
